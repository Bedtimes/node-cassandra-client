//
// Autogenerated by Thrift Compiler (0.7.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;

var ttypes = require('./cassandra_types');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args) {
  this.auth_request = null;
  if (args) {
    if (args.auth_request !== undefined) {
      this.auth_request = args.auth_request;
    }
  }
};
Cassandra_login_args.prototype = {};
Cassandra_login_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.auth_request = new ttypes.AuthenticationRequest();
        this.auth_request.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_login_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_login_args');
  if (this.auth_request != null) {
    output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 1);
    this.auth_request.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_login_result = function(args) {
  this.authnx = null;
  this.authzx = null;
  if (args) {
    if (args.authnx !== undefined) {
      this.authnx = args.authnx;
    }
    if (args.authzx !== undefined) {
      this.authzx = args.authzx;
    }
  }
};
Cassandra_login_result.prototype = {};
Cassandra_login_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.authnx = new ttypes.AuthenticationException();
        this.authnx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.authzx = new ttypes.AuthorizationException();
        this.authzx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_login_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_login_result');
  if (this.authnx != null) {
    output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1);
    this.authnx.write(output);
    output.writeFieldEnd();
  }
  if (this.authzx != null) {
    output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2);
    this.authzx.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_set_keyspace_args.prototype = {};
Cassandra_set_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_keyspace_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_keyspace_result = function(args) {
  this.ire = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_set_keyspace_result.prototype = {};
Cassandra_set_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_keyspace_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_args = function(args) {
  this.key = null;
  this.column_path = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_path !== undefined) {
      this.column_path = args.column_path;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_args.prototype = {};
Cassandra_get_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath();
        this.column_path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_path != null) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2);
    this.column_path.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_result = function(args) {
  this.success = null;
  this.ire = null;
  this.nfe = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.nfe !== undefined) {
      this.nfe = args.nfe;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_result.prototype = {};
Cassandra_get_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.ColumnOrSuperColumn();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException();
        this.nfe.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.nfe != null) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2);
    this.nfe.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 4);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_slice_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_slice_args.prototype = {};
Cassandra_get_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_slice_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_slice_result.prototype = {};
Cassandra_get_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size100 = 0;
        var _rtmp3104;
        this.success = [];
        var _etype103 = 0;
        _rtmp3104 = input.readListBegin();
        _etype103 = _rtmp3104.etype;
        _size100 = _rtmp3104.size;
        for (var _i105 = 0; _i105 < _size100; ++_i105)
        {
          var elem106 = null;
          elem106 = new ttypes.ColumnOrSuperColumn();
          elem106.read(input);
          this.success.push(elem106);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_slice_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter107 in this.success)
    {
      if (this.success.hasOwnProperty(iter107))
      {
        iter107 = this.success[iter107];
        iter107.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_count_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_count_args.prototype = {};
Cassandra_get_count_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_count_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_count_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_count_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_count_result.prototype = {};
Cassandra_get_count_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.I32) {
        this.success = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_count_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_count_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.I32, 0);
    output.writeI32(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_slice_args = function(args) {
  this.keys = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.keys !== undefined) {
      this.keys = args.keys;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_multiget_slice_args.prototype = {};
Cassandra_multiget_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size108 = 0;
        var _rtmp3112;
        this.keys = [];
        var _etype111 = 0;
        _rtmp3112 = input.readListBegin();
        _etype111 = _rtmp3112.etype;
        _size108 = _rtmp3112.size;
        for (var _i113 = 0; _i113 < _size108; ++_i113)
        {
          var elem114 = null;
          elem114 = input.readBinary();
          this.keys.push(elem114);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_slice_args');
  if (this.keys != null) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.keys.length);
    for (var iter115 in this.keys)
    {
      if (this.keys.hasOwnProperty(iter115))
      {
        iter115 = this.keys[iter115];
        output.writeString(iter115);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_multiget_slice_result.prototype = {};
Cassandra_multiget_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size116 = 0;
        var _rtmp3120;
        this.success = {};
        var _ktype117 = 0;
        var _vtype118 = 0;
        _rtmp3120 = input.readMapBegin();
        _ktype117 = _rtmp3120.ktype;
        _vtype118 = _rtmp3120.vtype;
        _size116 = _rtmp3120.size;
        for (var _i121 = 0; _i121 < _size116; ++_i121)
        {
          var key122 = null;
          var val123 = null;
          key122 = input.readBinary();
          var _size124 = 0;
          var _rtmp3128;
          val123 = [];
          var _etype127 = 0;
          _rtmp3128 = input.readListBegin();
          _etype127 = _rtmp3128.etype;
          _size124 = _rtmp3128.size;
          for (var _i129 = 0; _i129 < _size124; ++_i129)
          {
            var elem130 = null;
            elem130 = new ttypes.ColumnOrSuperColumn();
            elem130.read(input);
            val123.push(elem130);
          }
          input.readListEnd();
          this.success[key122] = val123;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_slice_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
    for (var kiter131 in this.success)
    {
      if (this.success.hasOwnProperty(kiter131))
      {
        var viter132 = this.success[kiter131];
        output.writeString(kiter131);
        output.writeListBegin(Thrift.Type.STRUCT, viter132.length);
        for (var iter133 in viter132)
        {
          if (viter132.hasOwnProperty(iter133))
          {
            iter133 = viter132[iter133];
            iter133.write(output);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_count_args = function(args) {
  this.keys = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.keys !== undefined) {
      this.keys = args.keys;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_multiget_count_args.prototype = {};
Cassandra_multiget_count_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size134 = 0;
        var _rtmp3138;
        this.keys = [];
        var _etype137 = 0;
        _rtmp3138 = input.readListBegin();
        _etype137 = _rtmp3138.etype;
        _size134 = _rtmp3138.size;
        for (var _i139 = 0; _i139 < _size134; ++_i139)
        {
          var elem140 = null;
          elem140 = input.readBinary();
          this.keys.push(elem140);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_count_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_count_args');
  if (this.keys != null) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.keys.length);
    for (var iter141 in this.keys)
    {
      if (this.keys.hasOwnProperty(iter141))
      {
        iter141 = this.keys[iter141];
        output.writeString(iter141);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_count_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_multiget_count_result.prototype = {};
Cassandra_multiget_count_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size142 = 0;
        var _rtmp3146;
        this.success = {};
        var _ktype143 = 0;
        var _vtype144 = 0;
        _rtmp3146 = input.readMapBegin();
        _ktype143 = _rtmp3146.ktype;
        _vtype144 = _rtmp3146.vtype;
        _size142 = _rtmp3146.size;
        for (var _i147 = 0; _i147 < _size142; ++_i147)
        {
          var key148 = null;
          var val149 = null;
          key148 = input.readBinary();
          val149 = input.readI32();
          this.success[key148] = val149;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_count_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_count_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
    for (var kiter150 in this.success)
    {
      if (this.success.hasOwnProperty(kiter150))
      {
        var viter151 = this.success[kiter150];
        output.writeString(kiter150);
        output.writeI32(viter151);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_range_slices_args = function(args) {
  this.column_parent = null;
  this.predicate = null;
  this.range = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.range !== undefined) {
      this.range = args.range;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_range_slices_args.prototype = {};
Cassandra_get_range_slices_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange();
        this.range.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_range_slices_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_range_slices_args');
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 2);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.range != null) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 3);
    this.range.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_range_slices_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_range_slices_result.prototype = {};
Cassandra_get_range_slices_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size152 = 0;
        var _rtmp3156;
        this.success = [];
        var _etype155 = 0;
        _rtmp3156 = input.readListBegin();
        _etype155 = _rtmp3156.etype;
        _size152 = _rtmp3156.size;
        for (var _i157 = 0; _i157 < _size152; ++_i157)
        {
          var elem158 = null;
          elem158 = new ttypes.KeySlice();
          elem158.read(input);
          this.success.push(elem158);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_range_slices_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_range_slices_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter159 in this.success)
    {
      if (this.success.hasOwnProperty(iter159))
      {
        iter159 = this.success[iter159];
        iter159.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_indexed_slices_args = function(args) {
  this.column_parent = null;
  this.index_clause = null;
  this.column_predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.index_clause !== undefined) {
      this.index_clause = args.index_clause;
    }
    if (args.column_predicate !== undefined) {
      this.column_predicate = args.column_predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_indexed_slices_args.prototype = {};
Cassandra_get_indexed_slices_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.index_clause = new ttypes.IndexClause();
        this.index_clause.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_predicate = new ttypes.SlicePredicate();
        this.column_predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_indexed_slices_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_indexed_slices_args');
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.index_clause != null) {
    output.writeFieldBegin('index_clause', Thrift.Type.STRUCT, 2);
    this.index_clause.write(output);
    output.writeFieldEnd();
  }
  if (this.column_predicate != null) {
    output.writeFieldBegin('column_predicate', Thrift.Type.STRUCT, 3);
    this.column_predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_indexed_slices_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_indexed_slices_result.prototype = {};
Cassandra_get_indexed_slices_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size160 = 0;
        var _rtmp3164;
        this.success = [];
        var _etype163 = 0;
        _rtmp3164 = input.readListBegin();
        _etype163 = _rtmp3164.etype;
        _size160 = _rtmp3164.size;
        for (var _i165 = 0; _i165 < _size160; ++_i165)
        {
          var elem166 = null;
          elem166 = new ttypes.KeySlice();
          elem166.read(input);
          this.success.push(elem166);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_indexed_slices_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_indexed_slices_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter167 in this.success)
    {
      if (this.success.hasOwnProperty(iter167))
      {
        iter167 = this.success[iter167];
        iter167.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_insert_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.column !== undefined) {
      this.column = args.column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_insert_args.prototype = {};
Cassandra_insert_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column();
        this.column.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_insert_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_insert_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.column != null) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3);
    this.column.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_insert_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_insert_result.prototype = {};
Cassandra_insert_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_insert_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_insert_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_add_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.column !== undefined) {
      this.column = args.column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_add_args.prototype = {};
Cassandra_add_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.CounterColumn();
        this.column.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_add_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_add_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.column != null) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3);
    this.column.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_add_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_add_result.prototype = {};
Cassandra_add_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_add_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_add_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_args = function(args) {
  this.key = null;
  this.column_path = null;
  this.timestamp = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_path !== undefined) {
      this.column_path = args.column_path;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_remove_args.prototype = {};
Cassandra_remove_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath();
        this.column_path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_path != null) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2);
    this.column_path.write(output);
    output.writeFieldEnd();
  }
  if (this.timestamp != null) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_remove_result.prototype = {};
Cassandra_remove_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_counter_args = function(args) {
  this.key = null;
  this.path = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.path !== undefined) {
      this.path = args.path;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_remove_counter_args.prototype = {};
Cassandra_remove_counter_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.path = new ttypes.ColumnPath();
        this.path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_counter_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_counter_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.path != null) {
    output.writeFieldBegin('path', Thrift.Type.STRUCT, 2);
    this.path.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_counter_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_remove_counter_result.prototype = {};
Cassandra_remove_counter_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_counter_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_counter_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_batch_mutate_args = function(args) {
  this.mutation_map = null;
  this.consistency_level = 1;
  if (args) {
    if (args.mutation_map !== undefined) {
      this.mutation_map = args.mutation_map;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_batch_mutate_args.prototype = {};
Cassandra_batch_mutate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        var _size168 = 0;
        var _rtmp3172;
        this.mutation_map = {};
        var _ktype169 = 0;
        var _vtype170 = 0;
        _rtmp3172 = input.readMapBegin();
        _ktype169 = _rtmp3172.ktype;
        _vtype170 = _rtmp3172.vtype;
        _size168 = _rtmp3172.size;
        for (var _i173 = 0; _i173 < _size168; ++_i173)
        {
          var key174 = null;
          var val175 = null;
          key174 = input.readBinary();
          var _size176 = 0;
          var _rtmp3180;
          val175 = {};
          var _ktype177 = 0;
          var _vtype178 = 0;
          _rtmp3180 = input.readMapBegin();
          _ktype177 = _rtmp3180.ktype;
          _vtype178 = _rtmp3180.vtype;
          _size176 = _rtmp3180.size;
          for (var _i181 = 0; _i181 < _size176; ++_i181)
          {
            var key182 = null;
            var val183 = null;
            key182 = input.readString();
            var _size184 = 0;
            var _rtmp3188;
            val183 = [];
            var _etype187 = 0;
            _rtmp3188 = input.readListBegin();
            _etype187 = _rtmp3188.etype;
            _size184 = _rtmp3188.size;
            for (var _i189 = 0; _i189 < _size184; ++_i189)
            {
              var elem190 = null;
              elem190 = new ttypes.Mutation();
              elem190.read(input);
              val183.push(elem190);
            }
            input.readListEnd();
            val175[key182] = val183;
          }
          input.readMapEnd();
          this.mutation_map[key174] = val175;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_batch_mutate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_batch_mutate_args');
  if (this.mutation_map != null) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map));
    for (var kiter191 in this.mutation_map)
    {
      if (this.mutation_map.hasOwnProperty(kiter191))
      {
        var viter192 = this.mutation_map[kiter191];
        output.writeString(kiter191);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter192));
        for (var kiter193 in viter192)
        {
          if (viter192.hasOwnProperty(kiter193))
          {
            var viter194 = viter192[kiter193];
            output.writeString(kiter193);
            output.writeListBegin(Thrift.Type.STRUCT, viter194.length);
            for (var iter195 in viter194)
            {
              if (viter194.hasOwnProperty(iter195))
              {
                iter195 = viter194[iter195];
                iter195.write(output);
              }
            }
            output.writeListEnd();
          }
        }
        output.writeMapEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_batch_mutate_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_batch_mutate_result.prototype = {};
Cassandra_batch_mutate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_batch_mutate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_batch_mutate_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_truncate_args = function(args) {
  this.cfname = null;
  if (args) {
    if (args.cfname !== undefined) {
      this.cfname = args.cfname;
    }
  }
};
Cassandra_truncate_args.prototype = {};
Cassandra_truncate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfname = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_truncate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_truncate_args');
  if (this.cfname != null) {
    output.writeFieldBegin('cfname', Thrift.Type.STRING, 1);
    output.writeString(this.cfname);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_truncate_result = function(args) {
  this.ire = null;
  this.ue = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
  }
};
Cassandra_truncate_result.prototype = {};
Cassandra_truncate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_truncate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_truncate_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_schema_versions_args = function(args) {
};
Cassandra_describe_schema_versions_args.prototype = {};
Cassandra_describe_schema_versions_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_schema_versions_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_schema_versions_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_schema_versions_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_schema_versions_result.prototype = {};
Cassandra_describe_schema_versions_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size196 = 0;
        var _rtmp3200;
        this.success = {};
        var _ktype197 = 0;
        var _vtype198 = 0;
        _rtmp3200 = input.readMapBegin();
        _ktype197 = _rtmp3200.ktype;
        _vtype198 = _rtmp3200.vtype;
        _size196 = _rtmp3200.size;
        for (var _i201 = 0; _i201 < _size196; ++_i201)
        {
          var key202 = null;
          var val203 = null;
          key202 = input.readString();
          var _size204 = 0;
          var _rtmp3208;
          val203 = [];
          var _etype207 = 0;
          _rtmp3208 = input.readListBegin();
          _etype207 = _rtmp3208.etype;
          _size204 = _rtmp3208.size;
          for (var _i209 = 0; _i209 < _size204; ++_i209)
          {
            var elem210 = null;
            elem210 = input.readString();
            val203.push(elem210);
          }
          input.readListEnd();
          this.success[key202] = val203;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_schema_versions_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_schema_versions_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
    for (var kiter211 in this.success)
    {
      if (this.success.hasOwnProperty(kiter211))
      {
        var viter212 = this.success[kiter211];
        output.writeString(kiter211);
        output.writeListBegin(Thrift.Type.STRING, viter212.length);
        for (var iter213 in viter212)
        {
          if (viter212.hasOwnProperty(iter213))
          {
            iter213 = viter212[iter213];
            output.writeString(iter213);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspaces_args = function(args) {
};
Cassandra_describe_keyspaces_args.prototype = {};
Cassandra_describe_keyspaces_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspaces_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspaces_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspaces_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_keyspaces_result.prototype = {};
Cassandra_describe_keyspaces_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size214 = 0;
        var _rtmp3218;
        this.success = [];
        var _etype217 = 0;
        _rtmp3218 = input.readListBegin();
        _etype217 = _rtmp3218.etype;
        _size214 = _rtmp3218.size;
        for (var _i219 = 0; _i219 < _size214; ++_i219)
        {
          var elem220 = null;
          elem220 = new ttypes.KsDef();
          elem220.read(input);
          this.success.push(elem220);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspaces_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspaces_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter221 in this.success)
    {
      if (this.success.hasOwnProperty(iter221))
      {
        iter221 = this.success[iter221];
        iter221.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_cluster_name_args = function(args) {
};
Cassandra_describe_cluster_name_args.prototype = {};
Cassandra_describe_cluster_name_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_cluster_name_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_cluster_name_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_cluster_name_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_cluster_name_result.prototype = {};
Cassandra_describe_cluster_name_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_cluster_name_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_cluster_name_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_version_args = function(args) {
};
Cassandra_describe_version_args.prototype = {};
Cassandra_describe_version_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_version_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_version_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_version_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_version_result.prototype = {};
Cassandra_describe_version_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_version_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_version_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_ring_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_describe_ring_args.prototype = {};
Cassandra_describe_ring_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_ring_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_ring_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_ring_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_ring_result.prototype = {};
Cassandra_describe_ring_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size222 = 0;
        var _rtmp3226;
        this.success = [];
        var _etype225 = 0;
        _rtmp3226 = input.readListBegin();
        _etype225 = _rtmp3226.etype;
        _size222 = _rtmp3226.size;
        for (var _i227 = 0; _i227 < _size222; ++_i227)
        {
          var elem228 = null;
          elem228 = new ttypes.TokenRange();
          elem228.read(input);
          this.success.push(elem228);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_ring_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_ring_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter229 in this.success)
    {
      if (this.success.hasOwnProperty(iter229))
      {
        iter229 = this.success[iter229];
        iter229.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_partitioner_args = function(args) {
};
Cassandra_describe_partitioner_args.prototype = {};
Cassandra_describe_partitioner_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_partitioner_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_partitioner_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_partitioner_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_partitioner_result.prototype = {};
Cassandra_describe_partitioner_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_partitioner_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_partitioner_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_snitch_args = function(args) {
};
Cassandra_describe_snitch_args.prototype = {};
Cassandra_describe_snitch_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_snitch_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_snitch_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_snitch_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_snitch_result.prototype = {};
Cassandra_describe_snitch_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_snitch_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_snitch_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_describe_keyspace_args.prototype = {};
Cassandra_describe_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspace_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspace_result = function(args) {
  this.success = null;
  this.nfe = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.nfe !== undefined) {
      this.nfe = args.nfe;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_keyspace_result.prototype = {};
Cassandra_describe_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.KsDef();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException();
        this.nfe.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.nfe != null) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1);
    this.nfe.write(output);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 2);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_args = function(args) {
  this.cfName = null;
  this.start_token = null;
  this.end_token = null;
  this.keys_per_split = null;
  if (args) {
    if (args.cfName !== undefined) {
      this.cfName = args.cfName;
    }
    if (args.start_token !== undefined) {
      this.start_token = args.start_token;
    }
    if (args.end_token !== undefined) {
      this.end_token = args.end_token;
    }
    if (args.keys_per_split !== undefined) {
      this.keys_per_split = args.keys_per_split;
    }
  }
};
Cassandra_describe_splits_args.prototype = {};
Cassandra_describe_splits_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_args');
  if (this.cfName != null) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1);
    output.writeString(this.cfName);
    output.writeFieldEnd();
  }
  if (this.start_token != null) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2);
    output.writeString(this.start_token);
    output.writeFieldEnd();
  }
  if (this.end_token != null) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3);
    output.writeString(this.end_token);
    output.writeFieldEnd();
  }
  if (this.keys_per_split != null) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4);
    output.writeI32(this.keys_per_split);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_splits_result.prototype = {};
Cassandra_describe_splits_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size230 = 0;
        var _rtmp3234;
        this.success = [];
        var _etype233 = 0;
        _rtmp3234 = input.readListBegin();
        _etype233 = _rtmp3234.etype;
        _size230 = _rtmp3234.size;
        for (var _i235 = 0; _i235 < _size230; ++_i235)
        {
          var elem236 = null;
          elem236 = input.readString();
          this.success.push(elem236);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRING, this.success.length);
    for (var iter237 in this.success)
    {
      if (this.success.hasOwnProperty(iter237))
      {
        iter237 = this.success[iter237];
        output.writeString(iter237);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_column_family_args = function(args) {
  this.cf_def = null;
  if (args) {
    if (args.cf_def !== undefined) {
      this.cf_def = args.cf_def;
    }
  }
};
Cassandra_system_add_column_family_args.prototype = {};
Cassandra_system_add_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef();
        this.cf_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_column_family_args');
  if (this.cf_def != null) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1);
    this.cf_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_add_column_family_result.prototype = {};
Cassandra_system_add_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_column_family_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_column_family_args = function(args) {
  this.column_family = null;
  if (args) {
    if (args.column_family !== undefined) {
      this.column_family = args.column_family;
    }
  }
};
Cassandra_system_drop_column_family_args.prototype = {};
Cassandra_system_drop_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_column_family_args');
  if (this.column_family != null) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1);
    output.writeString(this.column_family);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_drop_column_family_result.prototype = {};
Cassandra_system_drop_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_column_family_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_keyspace_args = function(args) {
  this.ks_def = null;
  if (args) {
    if (args.ks_def !== undefined) {
      this.ks_def = args.ks_def;
    }
  }
};
Cassandra_system_add_keyspace_args.prototype = {};
Cassandra_system_add_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef();
        this.ks_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_keyspace_args');
  if (this.ks_def != null) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1);
    this.ks_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_add_keyspace_result.prototype = {};
Cassandra_system_add_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_system_drop_keyspace_args.prototype = {};
Cassandra_system_drop_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_drop_keyspace_result.prototype = {};
Cassandra_system_drop_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_keyspace_args = function(args) {
  this.ks_def = null;
  if (args) {
    if (args.ks_def !== undefined) {
      this.ks_def = args.ks_def;
    }
  }
};
Cassandra_system_update_keyspace_args.prototype = {};
Cassandra_system_update_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef();
        this.ks_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_keyspace_args');
  if (this.ks_def != null) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1);
    this.ks_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_update_keyspace_result.prototype = {};
Cassandra_system_update_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_column_family_args = function(args) {
  this.cf_def = null;
  if (args) {
    if (args.cf_def !== undefined) {
      this.cf_def = args.cf_def;
    }
  }
};
Cassandra_system_update_column_family_args.prototype = {};
Cassandra_system_update_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef();
        this.cf_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_column_family_args');
  if (this.cf_def != null) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1);
    this.cf_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_update_column_family_result.prototype = {};
Cassandra_system_update_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_column_family_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql_query_args = function(args) {
  this.query = null;
  this.compression = null;
  if (args) {
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.compression !== undefined) {
      this.compression = args.compression;
    }
  }
};
Cassandra_execute_cql_query_args.prototype = {};
Cassandra_execute_cql_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql_query_args');
  if (this.query != null) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.compression != null) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2);
    output.writeI32(this.compression);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql_query_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_execute_cql_query_result.prototype = {};
Cassandra_execute_cql_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql_query_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var CassandraClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {};
};
CassandraClient.prototype = {};
CassandraClient.prototype.login = function(auth_request, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_login(auth_request);
};

CassandraClient.prototype.send_login = function(auth_request) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_login_args();
  args.auth_request = auth_request;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_login = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_login_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.authnx) {
    return callback(result.authnx);
  }
  if (null !== result.authzx) {
    return callback(result.authzx);
  }
  callback(null)
};
CassandraClient.prototype.set_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_set_keyspace(keyspace);
};

CassandraClient.prototype.send_set_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_set_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_set_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_set_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  callback(null)
};
CassandraClient.prototype.get = function(key, column_path, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get(key, column_path, consistency_level);
};

CassandraClient.prototype.send_get = function(key, column_path, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_args();
  args.key = key;
  args.column_path = column_path;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.nfe) {
    return callback(result.nfe);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get failed: unknown result');
};
CassandraClient.prototype.get_slice = function(key, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_slice(key, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_get_slice = function(key, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_slice_args();
  args.key = key;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_slice failed: unknown result');
};
CassandraClient.prototype.get_count = function(key, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_count(key, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_get_count = function(key, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_count_args();
  args.key = key;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_count_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_count failed: unknown result');
};
CassandraClient.prototype.multiget_slice = function(keys, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_multiget_slice(keys, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_multiget_slice = function(keys, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_multiget_slice_args();
  args.keys = keys;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_multiget_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('multiget_slice failed: unknown result');
};
CassandraClient.prototype.multiget_count = function(keys, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_multiget_count(keys, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_multiget_count = function(keys, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_count', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_multiget_count_args();
  args.keys = keys;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_multiget_count = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_multiget_count_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('multiget_count failed: unknown result');
};
CassandraClient.prototype.get_range_slices = function(column_parent, predicate, range, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_range_slices(column_parent, predicate, range, consistency_level);
};

CassandraClient.prototype.send_get_range_slices = function(column_parent, predicate, range, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_range_slices_args();
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.range = range;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_range_slices_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_range_slices failed: unknown result');
};
CassandraClient.prototype.get_indexed_slices = function(column_parent, index_clause, column_predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level);
};

CassandraClient.prototype.send_get_indexed_slices = function(column_parent, index_clause, column_predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_indexed_slices', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_indexed_slices_args();
  args.column_parent = column_parent;
  args.index_clause = index_clause;
  args.column_predicate = column_predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_indexed_slices = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_indexed_slices_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_indexed_slices failed: unknown result');
};
CassandraClient.prototype.insert = function(key, column_parent, column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_insert(key, column_parent, column, consistency_level);
};

CassandraClient.prototype.send_insert = function(key, column_parent, column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_insert_args();
  args.key = key;
  args.column_parent = column_parent;
  args.column = column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_insert_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.add = function(key, column_parent, column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_add(key, column_parent, column, consistency_level);
};

CassandraClient.prototype.send_add = function(key, column_parent, column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('add', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_add_args();
  args.key = key;
  args.column_parent = column_parent;
  args.column = column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_add = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_add_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.remove = function(key, column_path, timestamp, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_remove(key, column_path, timestamp, consistency_level);
};

CassandraClient.prototype.send_remove = function(key, column_path, timestamp, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_remove_args();
  args.key = key;
  args.column_path = column_path;
  args.timestamp = timestamp;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_remove_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.remove_counter = function(key, path, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_remove_counter(key, path, consistency_level);
};

CassandraClient.prototype.send_remove_counter = function(key, path, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove_counter', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_remove_counter_args();
  args.key = key;
  args.path = path;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_remove_counter = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_remove_counter_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.batch_mutate = function(mutation_map, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_batch_mutate(mutation_map, consistency_level);
};

CassandraClient.prototype.send_batch_mutate = function(mutation_map, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_batch_mutate_args();
  args.mutation_map = mutation_map;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_batch_mutate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.truncate = function(cfname, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_truncate(cfname);
};

CassandraClient.prototype.send_truncate = function(cfname) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('truncate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_truncate_args();
  args.cfname = cfname;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_truncate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_truncate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  callback(null)
};
CassandraClient.prototype.describe_schema_versions = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_schema_versions();
};

CassandraClient.prototype.send_describe_schema_versions = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_schema_versions', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_schema_versions_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_schema_versions = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_schema_versions_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_schema_versions failed: unknown result');
};
CassandraClient.prototype.describe_keyspaces = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_keyspaces();
};

CassandraClient.prototype.send_describe_keyspaces = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_keyspaces_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_keyspaces_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_keyspaces failed: unknown result');
};
CassandraClient.prototype.describe_cluster_name = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_cluster_name();
};

CassandraClient.prototype.send_describe_cluster_name = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_cluster_name_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_cluster_name_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_cluster_name failed: unknown result');
};
CassandraClient.prototype.describe_version = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_version();
};

CassandraClient.prototype.send_describe_version = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_version_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_version_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_version failed: unknown result');
};
CassandraClient.prototype.describe_ring = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_ring(keyspace);
};

CassandraClient.prototype.send_describe_ring = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_ring_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_ring_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_ring failed: unknown result');
};
CassandraClient.prototype.describe_partitioner = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_partitioner();
};

CassandraClient.prototype.send_describe_partitioner = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_partitioner', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_partitioner_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_partitioner = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_partitioner_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_partitioner failed: unknown result');
};
CassandraClient.prototype.describe_snitch = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_snitch();
};

CassandraClient.prototype.send_describe_snitch = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_snitch', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_snitch_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_snitch = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_snitch_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_snitch failed: unknown result');
};
CassandraClient.prototype.describe_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_keyspace(keyspace);
};

CassandraClient.prototype.send_describe_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.nfe) {
    return callback(result.nfe);
  }
  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_keyspace failed: unknown result');
};
CassandraClient.prototype.describe_splits = function(cfName, start_token, end_token, keys_per_split, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_splits(cfName, start_token, end_token, keys_per_split);
};

CassandraClient.prototype.send_describe_splits = function(cfName, start_token, end_token, keys_per_split) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_splits_args();
  args.cfName = cfName;
  args.start_token = start_token;
  args.end_token = end_token;
  args.keys_per_split = keys_per_split;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_splits_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_splits failed: unknown result');
};
CassandraClient.prototype.system_add_column_family = function(cf_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_add_column_family(cf_def);
};

CassandraClient.prototype.send_system_add_column_family = function(cf_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_add_column_family_args();
  args.cf_def = cf_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_add_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_add_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_add_column_family failed: unknown result');
};
CassandraClient.prototype.system_drop_column_family = function(column_family, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_drop_column_family(column_family);
};

CassandraClient.prototype.send_system_drop_column_family = function(column_family) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_drop_column_family_args();
  args.column_family = column_family;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_drop_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_drop_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_drop_column_family failed: unknown result');
};
CassandraClient.prototype.system_add_keyspace = function(ks_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_add_keyspace(ks_def);
};

CassandraClient.prototype.send_system_add_keyspace = function(ks_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_add_keyspace_args();
  args.ks_def = ks_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_add_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_add_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_add_keyspace failed: unknown result');
};
CassandraClient.prototype.system_drop_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_drop_keyspace(keyspace);
};

CassandraClient.prototype.send_system_drop_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_drop_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_drop_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_drop_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_drop_keyspace failed: unknown result');
};
CassandraClient.prototype.system_update_keyspace = function(ks_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_update_keyspace(ks_def);
};

CassandraClient.prototype.send_system_update_keyspace = function(ks_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_update_keyspace_args();
  args.ks_def = ks_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_update_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_update_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_update_keyspace failed: unknown result');
};
CassandraClient.prototype.system_update_column_family = function(cf_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_update_column_family(cf_def);
};

CassandraClient.prototype.send_system_update_column_family = function(cf_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_update_column_family_args();
  args.cf_def = cf_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_update_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_update_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_update_column_family failed: unknown result');
};
CassandraClient.prototype.execute_cql_query = function(query, compression, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_execute_cql_query(query, compression);
};

CassandraClient.prototype.send_execute_cql_query = function(query, compression) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_cql_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_execute_cql_query_args();
  args.query = query;
  args.compression = compression;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_execute_cql_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_execute_cql_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('execute_cql_query failed: unknown result');
};
var CassandraProcessor = exports.Processor = function(handler) {
  this._handler = handler
}
CassandraProcessor.prototype.process = function(input, output) {
  var r = input.readMessageBegin();
  if (this['process_' + r.fname]) {
    return this['process_' + r.fname].call(this, r.rseqid, input, output);
  } else {
    input.skip(Thrift.Type.STRUCT);
    input.readMessageEnd();
    var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
    output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid);
    x.write(output);
    output.writeMessageEnd();
    output.flush();
  }
}

CassandraProcessor.prototype.process_login = function(seqid, input, output) {
  var args = new Cassandra_login_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_login_result();
  this._handler.login(args.auth_request, function (success) {
    result.success = success;
    output.writeMessageBegin("login", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_set_keyspace = function(seqid, input, output) {
  var args = new Cassandra_set_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_set_keyspace_result();
  this._handler.set_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("set_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get = function(seqid, input, output) {
  var args = new Cassandra_get_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_result();
  this._handler.get(args.key, args.column_path, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_slice = function(seqid, input, output) {
  var args = new Cassandra_get_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_slice_result();
  this._handler.get_slice(args.key, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_count = function(seqid, input, output) {
  var args = new Cassandra_get_count_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_count_result();
  this._handler.get_count(args.key, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_count", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_multiget_slice = function(seqid, input, output) {
  var args = new Cassandra_multiget_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_multiget_slice_result();
  this._handler.multiget_slice(args.keys, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("multiget_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_multiget_count = function(seqid, input, output) {
  var args = new Cassandra_multiget_count_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_multiget_count_result();
  this._handler.multiget_count(args.keys, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("multiget_count", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_range_slices = function(seqid, input, output) {
  var args = new Cassandra_get_range_slices_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_range_slices_result();
  this._handler.get_range_slices(args.column_parent, args.predicate, args.range, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_range_slices", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_indexed_slices = function(seqid, input, output) {
  var args = new Cassandra_get_indexed_slices_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_indexed_slices_result();
  this._handler.get_indexed_slices(args.column_parent, args.index_clause, args.column_predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_indexed_slices", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_insert = function(seqid, input, output) {
  var args = new Cassandra_insert_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_insert_result();
  this._handler.insert(args.key, args.column_parent, args.column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("insert", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_add = function(seqid, input, output) {
  var args = new Cassandra_add_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_add_result();
  this._handler.add(args.key, args.column_parent, args.column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("add", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_remove = function(seqid, input, output) {
  var args = new Cassandra_remove_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_remove_result();
  this._handler.remove(args.key, args.column_path, args.timestamp, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_remove_counter = function(seqid, input, output) {
  var args = new Cassandra_remove_counter_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_remove_counter_result();
  this._handler.remove_counter(args.key, args.path, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("remove_counter", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_batch_mutate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_batch_mutate_result();
  this._handler.batch_mutate(args.mutation_map, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("batch_mutate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_truncate = function(seqid, input, output) {
  var args = new Cassandra_truncate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_truncate_result();
  this._handler.truncate(args.cfname, function (success) {
    result.success = success;
    output.writeMessageBegin("truncate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_schema_versions = function(seqid, input, output) {
  var args = new Cassandra_describe_schema_versions_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_schema_versions_result();
  this._handler.describe_schema_versions(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_schema_versions", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_keyspaces = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspaces_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_keyspaces_result();
  this._handler.describe_keyspaces(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_keyspaces", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_cluster_name = function(seqid, input, output) {
  var args = new Cassandra_describe_cluster_name_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_cluster_name_result();
  this._handler.describe_cluster_name(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_cluster_name", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_version = function(seqid, input, output) {
  var args = new Cassandra_describe_version_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_version_result();
  this._handler.describe_version(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_version", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_ring = function(seqid, input, output) {
  var args = new Cassandra_describe_ring_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_ring_result();
  this._handler.describe_ring(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_ring", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_partitioner = function(seqid, input, output) {
  var args = new Cassandra_describe_partitioner_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_partitioner_result();
  this._handler.describe_partitioner(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_partitioner", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_snitch = function(seqid, input, output) {
  var args = new Cassandra_describe_snitch_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_snitch_result();
  this._handler.describe_snitch(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_snitch", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_keyspace = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_keyspace_result();
  this._handler.describe_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_splits = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_splits_result();
  this._handler.describe_splits(args.cfName, args.start_token, args.end_token, args.keys_per_split, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_splits", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_add_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_add_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_add_column_family_result();
  this._handler.system_add_column_family(args.cf_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_add_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_drop_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_drop_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_drop_column_family_result();
  this._handler.system_drop_column_family(args.column_family, function (success) {
    result.success = success;
    output.writeMessageBegin("system_drop_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_add_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_add_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_add_keyspace_result();
  this._handler.system_add_keyspace(args.ks_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_add_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_drop_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_drop_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_drop_keyspace_result();
  this._handler.system_drop_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("system_drop_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_update_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_update_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_update_keyspace_result();
  this._handler.system_update_keyspace(args.ks_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_update_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_update_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_update_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_update_column_family_result();
  this._handler.system_update_column_family(args.cf_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_update_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_execute_cql_query = function(seqid, input, output) {
  var args = new Cassandra_execute_cql_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_execute_cql_query_result();
  this._handler.execute_cql_query(args.query, args.compression, function (success) {
    result.success = success;
    output.writeMessageBegin("execute_cql_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

